# use history, but skip certain cmds/args from being written:
function zshaddhistory() {
  local line cmd
  line=${1%%$'\n'} ; cmd=${line%% *}
  [[ ${#line} -ge 5
      && ${cmd} != (cp|cd|man|history|e|exit|cl|clear)
      && ${cmd} != (l[axclsftm]|srm|rm|rms|shred|rd|rds)
      && ${cmd} != (losetup|aespipe|crypsetup|sudo)
      && ${cmd} != (baer|baerp|habs|makepkg|go|startx|ay)
      && ${cmd} != (pacman|pacman-color|yaourt|bauerbill)
      && ${cmd} != (aive|lasi|lasid|daemons)
      && ${cmd} != ([mszx]edit|[zx]load|wika|xoc)
      && ${arg} != (*unrl*|*spar*)
  ]] && (( ! $argv[(I)*unrl*|*spar*] ))
}

# jump to previous directory by integer or reg-exp, also list dirs,
# else jump to last visited directory if no argument supplied:
function back() {
  if [[ -n $1 ]]; then
    case $1 in
      --)   dirs -lpv|sed '2s|$| \[last\]|' ;;
      <->)  pushd -q +$1 2>/dev/null ;;
      *)    [[ -n $(dirs -lpv|grep -i $1|grep -v ${PWD}) ]] && \
              pushd -q +${$(dirs -lpv|grep -i $1|grep -v ${PWD})[1]}
    esac
  else pushd -q - 2>/dev/null ; fi
}

# go up Nth amount of directories:
function up(){
  local arg=${1:-1};
  while [ ${arg} -gt 0 ]; do
    cd .. >&/dev/null;
    arg=$((${arg} - 1));
  done
}

# copy and follow file to new dir:
function cpf() {
  if [[ -d $*[-1] ]]; then
    cp $* && cd $*[-1]
  elif [[ -d ${*[-1]%/*} ]]; then
    cp $* && cd ${*[-1]%/*}
  fi
}

# move and follow file to new dir:
function mvf() {
  if [[ -d $*[-1] ]]; then
    mv $* && cd $*[-1]
  elif [[ -d ${*[-1]%/*} ]]; then
    mv $* && cd ${*[-1]%/*}
  fi
}

# use 'real' program, not an alias/function, etc:
function real() {
  if [[ -n $1 ]]; then
    prog=$(/usr/bin/which $1) &>/dev/null
    if [[ -x $(print ${prog}) ]]; then
      ${prog} ${@:/$1}
    fi
  else /bin/false ; fi
}

# native function for showing 256 colors, properly formatted:
function 256co() {
  for line in {0..15}; do
    for col in {0..15}; do
      code=$(( $col * 16 + ${line} ))
      printf $'\e[38;05;%dm %03d' ${code} ${code}
    done
  print ; done
}

# [TESTING] update/overwrite testing versions with final versions:
# NOTE: need to use 'find + file', etc, to determine where each file should go,
#       not just ~/code/shell... need to copy to ~/code/{lisp,lua,perl,python},etc..
#function codeup() {
#  for files in $(/bin/ls /usr/local/bin); do
#    for each in $(/bin/ls ${HOME}/code/shell|/bin/grep -x $files); do
#      for final in $(print ${$(diff -q /usr/local/bin/$each ${HOME}/code/shell/$each)[2]}); do
#        cp -v $final ${HOME}/code/shell
#      done
#    done
#  done
#}

# show ps information with simple output for scripts, quick views, etc:
function psi() {
  if [[ ${#${@:/$0}} -ge 2 ]]; then
    case $1 {
      '-C'|'-c')  real ps -C $2 hoargs ;;
      '-G'|'-g')  real ps -G $2 hoargs ;;
      '-U'|'-u')  real ps -U $2 hoargs ;;
      '-P'|'-p')  real ps -p $2 hoargs ;;
      '-S'|'-s')  real ps -s $2 hoargs ;;
      '-T'|'-t')  real ps -t $2 hoargs ;;
      *)  print "unrecognized option. read: man ps (section: process selection by list)" ;; }
  else print "invalid selection. read: man ps (section: process selection by list)" ; fi
}

# extract archive with preferred options:
function extr() {
  if [ -f $1 ]; then 
    case $1 in
      *.tar.bz2)   real tar xjf $1    ;;
      *.tar.gz)    real tar xzf $1    ;;
      *.bz2)       real bunzip2 $1    ;;
      *.rar)       real unrar e $1    ;;
      *.gz)        real gunzip $1     ;;
      *.tar)       real tar xf $1     ;;
      *.tbz2)      real tar xjf $1    ;;
      *.tgz)       real tar xzf $1    ;;
      *.zip)       real unzip $1      ;;
      *.Z)         real uncompress $1 ;;
      *.7z)        real 7z x $1       ;;
      *.xz)        real unxz -vk $1   ;;
      *.lzma)      real unlzma -vk $1 ;;
      *)           print "'$1' cannot be extracted via extr()" ;;
    esac
  else
    print "'$1' is not a valid file"
  fi
}

# {start,stop,restart} daemon:
function rcstart() {real sudo /etc/rc.d/$1 start}
function rcstop() {real sudo /etc/rc.d/$1 stop}
function rcrestart() {real sudo /etc/rc.d/$1 restart}

# quickly view definitions:
function sd() {
  local _ARG
  [[ $(print - $#@) -ge 2 ]] && _ARG=${@:/$1} || _ARG=$1
  case $1 in
    '-w'|'-wordnet') sdcv -u "WordNet" ${_ARG} 2>/dev/null ;;
    '-t'|'-thesaurus') sdcv -u "English Thesaurus" ${_ARG} 2>/dev/null ;;
    '-a'|'-all') sdcv ${_ARG} 2>/dev/null ;;
    *) sdcv -u "WordNet" ${_ARG} 2>/dev/null
  esac
}

# un-smart function for my todo lists:
function todo() {
  local _DIR=${HOME}/othe
  case $1 in
    l) real ls -1 ${_DIR}/.TODO* ;;
    *) real vim ${_DIR}/.TODO_$1 ;;
  esac
}

# one-liners:
function mkcd() {mkdir -p "$@" && cd "$@"}
function top10() {fc -l 0 |awk '{print $2}'|awk 'BEGIN {FS="|"} {print $1}'|sort|uniq -c|sort -rn|head -10}
function w3m() {[[ -z $1 ]] && real w3m ${HOMEPAGE} || real w3m ${@}}
function timec() {while sleep 1 ; do printf '\r%s ' "$(date +'%T %Y-%m-%d')" ; done}
function pubip() {curl http://whatismyip.org/ 2>/dev/null}
function qdep() {pacman-color -Q $@ $(pacman-color -Qi $@|grep Depends|cut -d: -f2-|sed -E 's|>\S+\>||g')}
