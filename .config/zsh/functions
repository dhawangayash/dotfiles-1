# use history, but skip certain cmds/args from being written:
function zshaddhistory() {
  local line cmd
  line=${1%%$'\n'} ; cmd=${line%% *}
  [[ ${#line} -ge 5
      && ${cmd} != (cd|history|fc|e|exit|cl|clear)
      && ${cmd} != (l[axclsftm]|srm|rms|rds|sudo)
      && ${cmd} != (losetup|aespipe|crypsetup|top10)
      && ${cmd} != (daemons|go|startx|mp)
      && ${cmd} != ([mszx]edit|[zx]load|wika|xoc)
  ]] && (( ! $argv[(I)*unrl*|*spar*] ))
}

# check ownership of given argument, as determined by pacman:
function owns() {
  if [[ -n $(for each in $(print ${PATH}|tr ':' '\n'); do
             find ${each}/$1 2>/dev/null ; done) ]]
  then /usr/bin/pacman -Qo $(which -p $1)
  else /usr/bin/pacman -Qo $1 ; fi
}

# jump to previous directory by integer or reg-exp, also list dirs,
# else jump to last visited directory if no argument supplied:
function back() {
  if [[ -n $1 ]]; then
    case $1 {
      --)   dirs -lpv|sed '2s|$| \[last\]|' ;;
      <->)  pushd -q +$1 2>/dev/null ;;
      *)    [[ -n $(dirs -lpv|grep -i $1|grep -v ${PWD}) ]] && \
              pushd -q +${$(dirs -lpv|grep -i $1|grep -v ${PWD})[1]}
    }
  else pushd -q - 2>/dev/null ; fi
}

# go up Nth amount of directories:
function up(){
  local arg=${1:-1};
  while [ ${arg} -gt 0 ]; do
    cd .. >&/dev/null;
    arg=$((${arg} - 1));
  done
}

# copy and follow file to new dir:
function cpf() {
  if [[ -d $*[-1] ]]; then
    cp $* && cd $*[-1]
  elif [[ -d ${*[-1]%/*} ]]; then
    cp $* && cd ${*[-1]%/*}
  fi
}

# move and follow file to new dir:
function mvf() {
  if [[ -d $*[-1] ]]; then
    mv $* && cd $*[-1]
  elif [[ -d ${*[-1]%/*} ]]; then
    mv $* && cd ${*[-1]%/*}
  fi
}

# use 'real' program, not an alias/function, etc:
#function real() {
#  if [[ -n $1 ]]; then
#    local prog=$(which -p $1) &>/dev/null
#    if [[ -x $(print ${prog}) ]]; then
#      ${prog} ${@:/$1}
#    fi
#  else /bin/false ; fi
#}

# native function for showing 256 colors, properly formatted:
function 256co() {
  if [[ ${TERM} != linux ]]; then
  for line in {0..15}; do for col in {0..15}; do
      local code=$(( $col * 16 + ${line} ))
      printf $'\e[38;05;%dm %03d' ${code} ${code}
    done
  print ; done
  fi
}

# [TESTING] update/overwrite testing versions with final versions:
# NOTE: need to use 'find + file', etc, to determine where each file should go,
#       not just ~/code/shell... need to copy to ~/code/{lisp,lua,perl,python},etc..
#function codeup() {
#  for files in $(/bin/ls /usr/local/bin); do
#    for each in $(/bin/ls ${HOME}/code/shell|/bin/grep -x $files); do
#      for final in $(print ${$(diff -q /usr/local/bin/$each ${HOME}/code/shell/$each)[2]}); do
#        cp -v $final ${HOME}/code/shell
#      done
#    done
#  done
#}


# show ps information with simple output for scripts, quick views, etc:
function psi() {
  if [[ ${#${@:/$0}} -ge 2 ]]; then
    case $1 {
      '-C'|'-c')  command ps -C $2 hopid,args ;; # by- command name
      '-G'|'-g')  command ps -G $2 hopid,args ;; # by- real group id (RGID)/name
      '-U'|'-u')  command ps -U $2 hopid,args ;; # by- effective user ID (EUID)/name
      '-P'|'-p')  command ps -p $2 hopid,args ;; # by- pid
      '-S'|'-s')  command ps -s $2 hopid,args ;; # by- session id
      '-T'|'-t')  command ps -t $2 hopid,args ;; # by- tty
      *)  print "unrecognized option. read: man ps (section: process selection by list)" ;; }
  else print "invalid selection. read: man ps (section: process selection by list)" ; fi
}

# extract archive with preferred options:
function extr() {
  if [ -f $1 ]; then 
    case $1 in
      *.tar.bz2)   command tar xjf $1    ;;
      *.tar.gz)    command tar xzf $1    ;;
      *.bz2)       command bunzip2 $1    ;;
      *.rar)       command unrar e $1    ;;
      *.gz)        command gunzip $1     ;;
      *.tar)       command tar xf $1     ;;
      *.tbz2)      command tar xjf $1    ;;
      *.tgz)       command tar xzf $1    ;;
      *.zip)       command unzip $1      ;;
      *.Z)         command uncompress $1 ;;
      *.7z)        command 7z x $1       ;;
      *.xz)        command unxz -vk $1   ;;
      *.lzma)      command unlzma -vk $1 ;;
      *)           print "'$1' cannot be extracted via extr()" ;;
    esac
  else
    print "'$1' is not a valid file"
  fi
}

# {start,stop,restart} daemon:
function rcstart() {command sudo /etc/rc.d/$1 start}
function rcstop() {command sudo /etc/rc.d/$1 stop}
function rcrestart() {command sudo /etc/rc.d/$1 restart}

# quickly view definitions:
function sd() {
  local _ARG
  [[ $(print - $#@) -ge 2 ]] && _ARG=${@:/$1} || _ARG=$1
  case $1 in
    '-w'|'-wordnet') sdcv -u "WordNet" ${_ARG} 2>/dev/null ;;
    '-t'|'-thesaurus') sdcv -u "English Thesaurus" ${_ARG} 2>/dev/null ;;
    '-a'|'-all') sdcv ${_ARG} 2>/dev/null ;;
    *) sdcv -u "WordNet" ${_ARG} 2>/dev/null
  esac
}

# un-smart function for my todo lists:
function todo() {
  local _d=${HOME}/othe
  case $1 in
    -*) command ls -1 ${_d}/.TODO* ;;
    *)  command vim ${_d}/.TODO_$1 ;;
  esac
}

# one-liners:
function mkcd() {mkdir -p "$@" && cd "$@"}
function top10() {fc -l 0|awk '{print $2}'|awk 'BEGIN {FS="|"} {print $1}'|sort|uniq -c|sort -rn|head -10}
function w3m() {[[ -z $1 ]] && command w3m ${HOMEPAGE} || command w3m ${@}}
function timec() {while sleep 1 ; do printf '\r%s ' "$(date +'%T %Y-%m-%d')" ; done}
function pubip() {curl http://whatismyip.org/ 2>/dev/null}
function qdep() {pacman-color -Q $@ $(pacman-color -Qi $@|grep Depends|cut -d: -f2-|sed -E 's|>\S+\>||g')}
