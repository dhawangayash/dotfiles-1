# use history, but skip certain cmds/args from being written:
function zshaddhistory {
  local line cmd
  line=${1%%$'\n'} ; cmd=${line%% *}
  [[ ${#line} -ge 5
      && ${cmd} != (history|fc|mpq|srm|rms|rds)
      && ${cmd} != ([szx]edit|[zx]load|zhist|wika)
  ]] && (( ! $argv[(I)*unrl*|*spar*|*losetup*|*aespipe*|*litika*|sudo rm*] ))
}

## test arguments and [if valid] prepend file:// to local requests:
#function {jumanji,vimprobable} {
#  setopt no_warncreateglobal
#  for i in {1..999}; do # this will break when arguments run out
#    if [[ ${+i} == 1 && ${(P)i} != ${(P)$(($i - 1))} ]]; then
#      if [[ -f $PWD/${(P)i} ]]; then __urls=(${__urls} file://$PWD/${(P)i})
#      elif [[ -f ${(P)i} ]]; then __urls=(${__urls} file://${(P)i})
#      else __urls=(${__urls} ${(P)i}) ; fi
#    else if [[ ${+__urls} == 1 ]]; then
#        command $0 ${__urls} 2>/dev/null ; unset __urls ; break ; fi ; fi
#  done
#}

# check ownership of given argument, as determined by pacman:
function owns {
  if [[ -n $(for each in ${PATH//:\\\n}; do
             find ${each}/$1 2>/dev/null ; done) ]]
  then pacman -Qo $(which -p $1)
  else pacman -Qo $1 ; fi
}

# jump to previous directory by integer or reg-exp, also list dirs,
# else jump to last visited directory if no argument supplied:
function back {
  if [[ $# == 1 ]]; then
    case $1 {
      <->)  pushd -q +$1 2>/dev/null ;;
      --)   dirs -lpv|sed '2s|$| \[last\]|' ;;
      *)    [[ -n $(dirs -lpv|grep -i $1|grep -v ${PWD}) ]] && \
              pushd -q +${$(dirs -lpv|grep -i $1|grep -v ${PWD})[1]}
    }
  else pushd -q - 2>/dev/null ; fi
}

# go up Nth amount of directories:
function up {
  local arg=${1:-1};
  while [ ${arg} -gt 0 ]; do
    cd .. >&/dev/null;
    arg=$((${arg} - 1));
  done
}

# copy and follow file to new dir:
function cpf {
  if [[ -d $*[-1] ]]; then
    cp $* && cd $*[-1]
  elif [[ -d ${*[-1]%/*} ]]; then
    cp $* && cd ${*[-1]%/*}
  fi
}

# move and follow file to new dir:
function mvf {
  if [[ -d $*[-1] ]]; then
    mv $* && cd $*[-1]
  elif [[ -d ${*[-1]%/*} ]]; then
    mv $* && cd ${*[-1]%/*}
  fi
}

# show ps information with simple output for scripts, quick views, etc:
function psi {
  if [[ ${#${@:/$0}} -ge 2 ]]; then
    case $1 {
      '-C'|'-c')  ps -C $2 hopid,args ;; # by- command name
      '-G'|'-g')  ps -G $2 hopid,args ;; # by- real group id (RGID)/name
      '-U'|'-u')  ps -U $2 hopid,args ;; # by- effective user ID (EUID)/name
      '-P'|'-p')  ps -p $2 hoargs ;;     # by- pid
      '-S'|'-s')  ps -s $2 hopid,args ;; # by- session id
      '-T'|'-t')  ps -t $2 hopid,args ;; # by- tty
      *)
        << EOP
(show process information by .. )
psi -c ARG  | command name
psi -g ARG  | group id
psi -u ARG  | user id
psi -p ARG  | pid
psi -s ARG  | session id
psi -t ARG  | tty
EOP
      ;; }
  else print "invalid selection. read: man ps (section: process selection by list)" ; fi
}

# native function for showing 256 colors, properly formatted:
function 256co {
  for line in {0..15}; do for col in {0..15}; do
      local code=$(( $col * 16 + ${line} ))
      printf $'\e[38;05;%dm %03d' ${code} ${code}
    done
  print ; done
}

# function to quickly play video files:
function mpq {
  setopt no_warncreateglobal
  [[ -z ${DISPLAY} && $(tty) = /dev/tty[1-3] ]] && _mopt=(-vo fbdev)
  case $1 {
    'm') local _vol=${$(command ossmix|grep outvol)[-2]}
         command ossmix vmix0-outvol 25 &>/dev/null
         command mplayer ${_mopt} -volume 100 -fs -really-quiet -msglevel all=0 ${@:/$1} &>/dev/null
         command ossmix vmix0-outvol ${_vol} &>/dev/null ;;
    *)   command mplayer ${_mopt} -volume 100 -really-quiet -msglevel all=0 ${@} &>/dev/null
  }
  setopt warncreateglobal
}

# function to quickly view word definitions:
function sd {
  case $1 in
    '-r'|'-ru') sdcv -u "en-ru-bars" ${@:/$1} 2>/dev/null ;;
    '-w'|'-wordnet') sdcv -u "WordNet" ${@:/$1} 2>/dev/null ;;
    '-t'|'-thesaurus') sdcv -u "English Thesaurus" ${@:/$1} 2>/dev/null ;;
    '-a'|'-all') sdcv ${@:/$1} 2>/dev/null ;;
    *) sdcv $@ 2>/dev/null
  esac
}

# un-smart function for my todo lists:
function todo {
  case $# {
    0) command ls -1 ${H:-/howl}/othe/.TODO_* ;;
    1) command vim ${H:-/howl}/othe/.TODO_$1 ;;
    *) command vim ${H:-/howl}/othe/.TODO_${@// /_}
  }
}

# un-smart function for viewing/editing history file (still use 'fc/history'):
function zhist {
  if [[ $# == 1 ]]; then
    case $1 {
      e)  ${EDITOR:-/usr/bin/vim} ${ZDOTDIR:-${HOME}/zsh}/.history ;;
      a)  <${ZDOTDIR:-${HOME}/zsh}/.history | less ;;
      *)  <${ZDOTDIR:-${HOME}/zsh}/.history|grep -i $1
    }
  fi
}

# quirky tmux function:
function tmux {
  if [[ ${@[-2]} == '--' ]]; then
    command tmux ${@%--}
  else
    case ${+DISPLAY} in
      0)  command tmux -S /tmp/.${UID}/tmux/default $@ ;;
      1)  command tmux -S /tmp/.${UID}/tmux/xorg $@ ;;
    esac
  fi
}

# one-liners/micro functions:
function flashproc { for f (${$(file /proc/$(pidof luakit)/fd/*|gawk '/\/tmp\/Flash/ {print $1}')//:}){print - "$f"} }
function lss { ls -- ${1:-.}/*(D.om) }
function rc { [[ -n $1 ]] && sudo /etc/rc.d/$1 ${@:/$1} }
function alv { <${${$(command find ${H:-/howl}/othe/archive/installed_*)}[${1:--1}]}|w3m -o pagerline=1000 -o confirm_qq=0 }
function mkcd { command mkdir -p "$@" && cd "$@" }
function pubip { curl -m 30 http://www.whatismyip.com/automation/n09230945.asp }
function newmail { print - ${(Fw)#$(find /howl/mail/*/*/new -type f)} }
function qdep { pacman-color -Q $@ $(pacman-color -Qi $@|grep Depends|cut -d: -f2-|sed -E 's|>\S+\>||g') }
function timec { print "$(date +'%T %Y-%m-%d')" ; while sleep 1 ; do printf '\r%s ' "$(date +'%T %Y-%m-%d')" ; done }
function dropcache { sync && command su -s /bin/zsh -c 'echo 1 > /proc/sys/vm/drop_caches && echo 2 > /proc/sys/vm/drop_caches' root }
